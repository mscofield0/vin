pub use anyhow;
pub use downcast_rs;

use async_trait::async_trait;
use lazy_static::lazy_static;
use downcast_rs::Downcast;
use tokio::sync::Notify;
use std::{
    sync::atomic::{AtomicUsize, Ordering::*}, 
    time::Duration, 
    fmt::Debug, 
    collections::HashMap,
};

/// Marker trait indicating that the type is a message.
pub trait Message: Downcast + Send {
    fn id(&self) -> core::any::TypeId {
        self.type_id()
    }
}

impl<T: Send + 'static> Message for T {}
downcast_rs::impl_downcast!(Message);

/// Forwards the message to the respective mailbox.
#[async_trait]
pub trait Forwarder<M: Message> {
    async fn forward(&self, msg: M);
}

/// Handler for specifying message handling logic.
#[async_trait]
pub trait Handler<M: Message> {
    async fn handle(&self, msg: M) -> anyhow::Result<()>;
}

/// Helper wrapper that provides message name information alongside the handler error.
pub struct HandlerError {
    inner: anyhow::Error,
    msg_name: &'static str,
}

impl HandlerError {
    pub fn new(msg_name: &'static str, err: anyhow::Error) -> Self {
        Self { msg_name, inner: err }
    }

    pub fn msg_name(&self) -> &'static str {
        self.msg_name
    }
}

impl ::core::fmt::Debug for HandlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.inner.fmt(f)
    }
}

/// Actor trait that all actors must implement.
/// 
/// Implementation is generated by the `vin::actor` proc macro.
#[async_trait]
pub trait Actor: Addr + LifecycleHook + Send + Sync {
    type Context;

    // impl'd by derive macro
    fn new(ctx: Self::Context) -> StrongAddr<Self>;
    async fn ctx(&self) -> tokio::sync::RwLockReadGuard<Self::Context>;
    async fn ctx_mut(&self) -> tokio::sync::RwLockWriteGuard<Self::Context>;
    async fn start(self: &StrongAddr<Self>) -> StrongAddr<Self>;
}

#[async_trait]
pub trait Addr: Send + Sync {
    async fn send<M: Message + Send>(&self, msg: M) where Self: Forwarder<M> + Sized;
    async fn send_erased(&self, msg: BoxedMessage);
    fn state(&self) -> State;
    fn close(&self);
    
    fn is_started(&self) -> bool {
        self.state() != State::Pending
    }

    fn is_closed(&self) -> bool {
        self.state() == State::Closing || self.state() == State::Closed
    }
}

/// Used to call arbitrary code on state changes.
/// 
/// ## Example
/// ```rust
/// #[derive(Debug, Clone)]
/// enum Message {
///     Foo,
///     Bar,
/// }
/// 
/// #[vin::actor]
/// #[vin::handles(Message)]
/// struct MyActor;
/// 
/// #[async_trait]
/// impl vin::LifecycleHook for MyActor {
///     async fn on_started(&self) {
///         println!("Started!");
///     }
/// }
/// ```
#[async_trait]
pub trait LifecycleHook {
    async fn on_started(&self) {}
    async fn on_closing(&self) {}
    async fn on_closed(&self) {}
}

#[async_trait]
pub trait ErasedTx: Send + Sync {
    async fn send_erased(&self, msg: BoxedMessage);
}

/// Actor lifecycle states.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum State {
    Pending,
    Starting,
    Running,
    Closing,
    Closed,
}

impl Default for State {
    fn default() -> Self {
        Self::Pending
    }
}

/// Actor identifier marker trait for the actor registry.
pub type ActorId = std::borrow::Cow<'static, str>;

/// A strong typed reference to the spawned actor.
pub type StrongAddr<A> = std::sync::Arc<A>;

/// A weak typed reference to the spawned actor.
pub type WeakAddr<A> = std::sync::Weak<A>;

/// A strong erased reference to the spawned actor.
pub type StrongErasedAddr = std::sync::Arc<dyn Addr>;

/// A weak erased reference to the spawned actor.
pub type WeakErasedAddr = std::sync::Weak<dyn Addr>;

/// A boxed Message.
pub type BoxedMessage = Box<dyn Message>;

/// A boxed ErasedTx.
pub type BoxedErasedTx = Box<dyn ErasedTx>;

/// Global actor shutdown signal.
pub static SHUTDOWN_SIGNAL: Notify = Notify::const_new();

/// Number of actors alive.
pub static ACTORS_ALIVE: AtomicUsize = AtomicUsize::new(0);


/// Sends a shutdown signal to all actors.
pub fn shutdown() {
    SHUTDOWN_SIGNAL.notify_waiters();
}

/// Registers an actor in the actor counter.
pub fn add_actor() {
    ACTORS_ALIVE.fetch_add(1, Release);
}

/// Unregisters an actor in the actor counter.
pub fn remove_actor() {
    ACTORS_ALIVE.fetch_sub(1, Release);
}

/// Waits for all actors to shutdown gracefully.
pub async fn wait_for_shutdowns() {
    while ACTORS_ALIVE.load(Acquire) != 0 {
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
}
