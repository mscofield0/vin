use async_trait::async_trait;
use tokio::sync::Notify;
use std::{sync::atomic::{AtomicUsize, Ordering::*}, time::Duration};

/// Marker trait indicating that the type is a message.
pub trait Message {}
impl<T> Message for T {}

/// Forwards the message to the respective mailbox.
#[async_trait]
pub trait Forwarder<M: Message> {
    async fn forward(&self, msg: M);
}

/// Handler for specifying message handling logic.
#[async_trait]
pub trait Handler<M: Message> {
    async fn handle(&self, msg: M);
}

/// Actor trait that all actors must implement.
/// 
/// Implementation is generated by the `vin::actor` proc macro.
#[async_trait]
pub trait Actor {
    type Context;

    // impl'd by derive macro
    fn new(ctx: Self::Context) -> Self;
    fn state(&self) -> State;
    fn close(&self);
    async fn ctx(&self) -> tokio::sync::RwLockReadGuard<Self::Context>;
    async fn ctx_mut(&self) -> tokio::sync::RwLockWriteGuard<Self::Context>;
    async fn send<M: Message + Send>(&self, msg: M) where Self: Forwarder<M>;
    async fn start(self) -> Addr<Self>
        where Self: LifecycleHook;

    // blanket
    fn is_started(&self) -> bool {
        self.state() != State::Pending
    }

    fn is_closed(&self) -> bool {
        self.state() == State::Closing || self.state() == State::Closed
    }
}

/// Used to call arbitrary code on state changes.
/// 
/// ## Example
/// ```rust
/// #[derive(Debug, Clone)]
/// enum Message {
///     Foo,
///     Bar,
/// }
/// 
/// #[vin::actor]
/// #[vin::handles(Message)]
/// struct MyActor;
/// 
/// #[async_trait]
/// impl vin::LifecycleHook for MyActor {
///     async fn on_started(&self) {
///         println!("Started!");
///     }
/// }
/// ```
#[async_trait]
pub trait LifecycleHook {
    async fn on_started(&self) {}
    async fn on_closing(&self) {}
    async fn on_closed(&self) {}
}

/// Actor lifecycle states.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum State {
    Pending,
    Starting,
    Running,
    Closing,
    Closed,
}

impl Default for State {
    fn default() -> Self {
        Self::Pending
    }
}

/// A reference to the spawned actor.
pub type Addr<A> = std::sync::Arc<A>;

/// Global actor shutdown signal.
pub static SHUTDOWN_SIGNAL: Notify = Notify::const_new();

/// Number of actors alive.
pub static ACTORS_ALIVE: AtomicUsize = AtomicUsize::new(0);

/// Sends a shutdown signal to all actors.
pub fn shutdown() {
    SHUTDOWN_SIGNAL.notify_waiters();
}

/// Registers an actor in the actor counter.
pub fn add_actor() {
    ACTORS_ALIVE.fetch_add(1, Release);
}

/// Unregisters an actor in the actor counter.
pub fn remove_actor() {
    ACTORS_ALIVE.fetch_sub(1, Release);
}

/// Waits for all actors to shutdown gracefully.
pub async fn wait_for_shutdowns() {
    while ACTORS_ALIVE.load(Acquire) != 0 {
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
}
